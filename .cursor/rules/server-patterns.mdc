---
alwaysApply: true
---
# Server Components & Server Actions Patterns

This project follows strict server-side data patterns for security and type safety.

## Core Principles

1. **Database Query Functions**: All database operations must go through helper functions in the `db/queries` directory
2. **Server Components for Data Retrieval**: Server Components call query functions for data fetching
3. **Server Actions for Mutations**: Server Actions call mutation functions (also in `db/queries`)
4. **Zod Validation**: All data validation must use Zod schemas
5. **TypeScript Types**: All function inputs must be validated by Zod and have explicit TypeScript types (never use `formData` as a type)
6. **Never Direct Database Access**: Components and actions must never import or use `db` directly - always use query functions

## Query Functions Architecture

### Directory Structure

```
src/
  db/
    queries/
      decks.ts          # Deck-related queries and mutations
      cards.ts          # Card-related queries and mutations
      reviews.ts        # Review/spaced-repetition queries
    index.ts
    schema.ts
```

### Query Function Pattern

All database operations must be encapsulated in functions within `db/queries`:

```typescript
// db/queries/decks.ts
import { db } from "@/db";
import { decksTable } from "@/db/schema";
import { eq, and, desc } from "drizzle-orm";
import type { InferSelectModel } from "drizzle-orm";

export type Deck = InferSelectModel<typeof decksTable>;

// Query function for reading data
export async function getUserDecks(userId: string): Promise<Deck[]> {
  return await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.clerkUserId, userId))
    .orderBy(desc(decksTable.updatedAt));
}

export async function getDeckById(deckId: number, userId: string): Promise<Deck | undefined> {
  return await db.query.decksTable.findFirst({
    where: and(
      eq(decksTable.id, deckId),
      eq(decksTable.clerkUserId, userId)
    ),
    with: { cards: true }
  });
}

// Mutation function for creating data
export async function createDeck(data: {
  userId: string;
  title: string;
  description?: string;
}): Promise<Deck> {
  const [newDeck] = await db
    .insert(decksTable)
    .values({
      clerkUserId: data.userId,
      title: data.title,
      description: data.description,
    })
    .returning();
  
  return newDeck;
}

// Mutation function for updating data
export async function updateDeck(data: {
  deckId: number;
  userId: string;
  title: string;
  description?: string;
}): Promise<Deck | null> {
  const [updatedDeck] = await db
    .update(decksTable)
    .set({
      title: data.title,
      description: data.description,
      updatedAt: new Date(),
    })
    .where(
      and(
        eq(decksTable.id, data.deckId),
        eq(decksTable.clerkUserId, data.userId)
      )
    )
    .returning();
  
  return updatedDeck || null;
}

// Mutation function for deleting data
export async function deleteDeck(deckId: number, userId: string): Promise<boolean> {
  const result = await db
    .delete(decksTable)
    .where(
      and(
        eq(decksTable.id, deckId),
        eq(decksTable.clerkUserId, userId)
      )
    );
  
  return result.rowCount > 0;
}
```

## Data Retrieval Pattern

### ✅ CORRECT - Server Component with Query Functions

```typescript
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { getUserDecks } from "@/db/queries/decks";

export default async function DecksPage() {
  const { userId } = await auth();
  
  if (!userId) {
    redirect("/");
  }
  
  // Use query function - never access db directly
  const decks = await getUserDecks(userId);
  
  return (
    <div>
      {decks.map(deck => (
        <DeckCard key={deck.id} deck={deck} />
      ))}
    </div>
  );
}
```

### ❌ WRONG - Direct Database Access in Component

```typescript
// DON'T DO THIS - Never import db directly in components/actions
import { db } from "@/db";
import { decksTable } from "@/db/schema";
import { eq } from "drizzle-orm";

export default async function DecksPage() {
  const { userId } = await auth();
  
  // ❌ Direct database access - violates architecture
  const decks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.clerkUserId, userId));
  
  return <div>...</div>;
}
```

### ❌ WRONG - API Route for Data Fetching

```typescript
// Don't create API routes just to fetch data
export async function GET() {
  const decks = await db.select().from(decksTable);
  return Response.json(decks);
}

// Don't use client-side fetching for database queries
"use client";
export default function DecksPage() {
  const [decks, setDecks] = useState([]);
  
  useEffect(() => {
    fetch("/api/decks").then(r => r.json()).then(setDecks);
  }, []);
}
```

## Data Mutation Pattern

### Step 1: Define Zod Schema

Create validation schemas for all Server Action inputs:

```typescript
// app/dashboard/schemas.ts
import { z } from "zod";

export const createDeckSchema = z.object({
  title: z.string().min(1, "Title is required").max(100),
  description: z.string().max(500).optional(),
});

export const updateCardSchema = z.object({
  cardId: z.number().positive(),
  question: z.string().min(1, "Question is required"),
  answer: z.string().min(1, "Answer is required"),
});

export const deleteItemSchema = z.object({
  id: z.number().positive(),
});

// Export TypeScript types from schemas
export type CreateDeckInput = z.infer<typeof createDeckSchema>;
export type UpdateCardInput = z.infer<typeof updateCardSchema>;
export type DeleteItemInput = z.infer<typeof deleteItemSchema>;
```

### Step 2: Create Server Action that Uses Query Functions

```typescript
"use server";

import { auth } from "@clerk/nextjs/server";
import { revalidatePath } from "next/cache";
import { createDeck as createDeckQuery } from "@/db/queries/decks";
import { createDeckSchema, type CreateDeckInput } from "./schemas";

export async function createDeckAction(input: CreateDeckInput) {
  // 1. Validate input with Zod
  const validatedInput = createDeckSchema.parse(input);
  
  // 2. Authenticate user
  const { userId } = await auth();
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  // 3. Call query function - NEVER access db directly
  const newDeck = await createDeckQuery({
    userId,
    title: validatedInput.title,
    description: validatedInput.description,
  });
  
  // 4. Revalidate affected paths
  revalidatePath("/dashboard");
  
  return { success: true, deck: newDeck };
}
```

### Step 3: Use Server Action in Client Component

```typescript
"use client";

import { useState } from "react";
import { createDeckAction } from "./actions";
import type { CreateDeckInput } from "./schemas";

export function CreateDeckForm() {
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  async function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    setIsSubmitting(true);
    
    const formData = new FormData(e.currentTarget);
    
    // Create typed object (NOT formData type!)
    const input: CreateDeckInput = {
      title: formData.get("title") as string,
      description: formData.get("description") as string,
    };
    
    try {
      await createDeckAction(input);
      e.currentTarget.reset();
    } catch (error) {
      console.error("Failed to create deck:", error);
    } finally {
      setIsSubmitting(false);
    }
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <input name="title" required />
      <textarea name="description" />
      <button type="submit" disabled={isSubmitting}>
        Create Deck
      </button>
    </form>
  );
}
```

## Complete Server Actions Example

```typescript
"use server";

import { auth } from "@clerk/nextjs/server";
import { revalidatePath } from "next/cache";
import { z } from "zod";
import { updateDeck as updateDeckQuery } from "@/db/queries/decks";
import { deleteCard as deleteCardQuery, getDeckById } from "@/db/queries/cards";

// Schemas
const updateDeckSchema = z.object({
  deckId: z.number().positive(),
  title: z.string().min(1).max(100),
  description: z.string().max(500).optional(),
});

const deleteCardSchema = z.object({
  cardId: z.number().positive(),
  deckId: z.number().positive(),
});

// Types
type UpdateDeckInput = z.infer<typeof updateDeckSchema>;
type DeleteCardInput = z.infer<typeof deleteCardSchema>;

// Actions
export async function updateDeckAction(input: UpdateDeckInput) {
  const validated = updateDeckSchema.parse(input);
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  // Use query function - never access db directly
  const updatedDeck = await updateDeckQuery({
    deckId: validated.deckId,
    userId,
    title: validated.title,
    description: validated.description,
  });
  
  if (!updatedDeck) {
    throw new Error("Deck not found or access denied");
  }
  
  revalidatePath("/dashboard");
  revalidatePath(`/decks/${validated.deckId}`);
  
  return { success: true, deck: updatedDeck };
}

export async function deleteCardAction(input: DeleteCardInput) {
  const validated = deleteCardSchema.parse(input);
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  // Use query function to verify deck ownership
  const deck = await getDeckById(validated.deckId, userId);
  
  if (!deck) {
    throw new Error("Deck not found or access denied");
  }
  
  // Use query function to delete card
  const success = await deleteCardQuery(validated.cardId, validated.deckId);
  
  if (!success) {
    throw new Error("Card not found");
  }
  
  revalidatePath(`/decks/${validated.deckId}`);
  
  return { success: true };
}
```

## Query Functions for Cards Example

```typescript
// db/queries/cards.ts
import { db } from "@/db";
import { cardsTable, decksTable } from "@/db/schema";
import { eq, and } from "drizzle-orm";
import type { InferSelectModel } from "drizzle-orm";

export type Card = InferSelectModel<typeof cardsTable>;

export async function getCardsByDeckId(deckId: number): Promise<Card[]> {
  return await db
    .select()
    .from(cardsTable)
    .where(eq(cardsTable.deckId, deckId));
}

export async function getDeckById(deckId: number, userId: string) {
  return await db.query.decksTable.findFirst({
    where: and(
      eq(decksTable.id, deckId),
      eq(decksTable.clerkUserId, userId)
    ),
  });
}

export async function deleteCard(cardId: number, deckId: number): Promise<boolean> {
  const result = await db
    .delete(cardsTable)
    .where(
      and(
        eq(cardsTable.id, cardId),
        eq(cardsTable.deckId, deckId)
      )
    );
  
  return result.rowCount > 0;
}
```

## Validation Best Practices

1. **Always validate at the boundary**: Parse input immediately in Server Actions
2. **Use Zod transforms**: Leverage `.transform()` for data normalization
3. **Provide helpful error messages**: Use custom error messages in schemas
4. **Handle validation errors**: Catch `ZodError` and return user-friendly messages

```typescript
export async function createDeck(input: CreateDeckInput) {
  try {
    const validated = createDeckSchema.parse(input);
    // ... rest of action
  } catch (error) {
    if (error instanceof z.ZodError) {
      return {
        success: false,
        errors: error.flatten().fieldErrors,
      };
    }
    throw error;
  }
}
```

## File Organization

### Directory Structure
```
src/
  db/
    queries/
      decks.ts          # All deck-related database operations
      cards.ts          # All card-related database operations
      reviews.ts        # All review/spaced-repetition operations
    index.ts            # Database connection export
    schema.ts           # Drizzle schema definitions
  app/
    dashboard/
      actions.ts        # Server actions for dashboard
      schemas.ts        # Zod validation schemas
      page.tsx          # Server component
```

### Organization Rules

- **Query Functions**: All database operations in `db/queries/` directory
  - Group by domain (decks, cards, reviews)
  - Export types using `InferSelectModel` and `InferInsertModel`
  - Each function handles ONE specific database operation
  - Include security checks (userId validation) within query functions

- **Schemas**: Define Zod schemas in separate files per feature
  - Location: `app/[feature]/schemas.ts`
  - Export both schemas and inferred TypeScript types
  - Keep validation logic close to where it's used

- **Server Actions**: Group related actions by feature
  - Location: `app/[feature]/actions.ts`
  - Always marked with `"use server"`
  - Call query functions (never access `db` directly)
  - Handle authentication, validation, and revalidation

- **Server Components**: Fetch data using query functions
  - Call query functions directly (no API routes)
  - Handle authentication before calling queries
  - Pass data to client components via props

## Summary Checklist

For every database operation, ensure:

- [ ] **Query function exists** in `db/queries/` directory
- [ ] **Never import `db` directly** in components or actions
- [ ] Data retrieval is done in Server Components via query functions
- [ ] Mutations are done via Server Actions that call query functions
- [ ] Zod schema is defined for all inputs
- [ ] TypeScript type is inferred from Zod schema
- [ ] Server Action parameter has explicit type (never `formData` type)
- [ ] Input is validated with `.parse()` or `.safeParse()`
- [ ] User authentication is checked in Server Action/Component
- [ ] User authorization is verified (ownership) in query function
- [ ] `revalidatePath()` is called after mutations
- [ ] Errors are handled gracefully
- [ ] Query functions have proper TypeScript return types

**Never:**
- Import `db` directly in Server Components or Server Actions
- Use API routes for data fetching
- Skip Zod validation
- Use `any` or `formData` as Server Action parameter types
- Trust client-provided user IDs or ownership claims
- Forget to revalidate paths after mutations
- Put business logic in components instead of query functions

## Benefits of Query Functions Pattern

1. **Separation of Concerns**: Database logic is isolated from UI and action logic
2. **Reusability**: Query functions can be used across multiple components and actions
3. **Testability**: Query functions can be unit tested independently
4. **Type Safety**: Centralized types for all database operations
5. **Security**: Authorization logic is encapsulated in query functions
6. **Maintainability**: Database changes only affect query functions, not scattered throughout the app
7. **Code Organization**: Clear structure makes codebase easier to navigate
